{"mappings":"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","sources":["src/services/CalculateOneSleepCycleService.ts","src/services/CalculateOneSleepCycleLaterService.ts","src/util/dateToTimeString.ts","src/presentation/Tab.ts","src/presentation/TabSleep.ts","src/services/CalculateOneSleepCycleBeforeService.ts","src/presentation/TabWakeUp.ts","src/presentation/TabManager.ts","src/presentation/TabManagerMenu.ts","src/presentation/TabAbout.ts","src/main.ts"],"sourcesContent":["export interface Args {\n  baseTime: string\n  oneSleepCycleDurationInMinutes?: number\n  minimumAmountOfSleepInMinutes?: number\n}\n\n/**\n * Ideia\n *\n * OneSleepCycle.later()\n * OneSleepCycle.before()\n * já que os dois usam a mesma operação, mas com ordem trocada dos\n * operandos\n */\n\n/**\n * Classe base que calcula horários baseados em `baseTime` em intervalos de\n * tempo de `sleepCycleDurationInMinutes`. As classes que herdam dela devem\n * implementar o método `operation`. A implementação de `operation` determina\n * se a classe filha calcula um novo horário antes ou depois de `baseTime`.\n *\n * @param {string} baseTime horário base no formato HH:mm\n * @param {number} sleepCycleDurationInMinutes duração de um ciclo de sono em minutos\n */\nexport default abstract class CalculateOneSleepCycleService {\n  private readonly MINIMUM_MINUTES = 15\n  protected readonly DEFAULT_DATE = '2000-01-01'\n  protected readonly baseDate: Date\n  protected newBaseDate: Date\n  protected baseTime: string\n  protected newBaseTime: string\n  protected oneSleepCycleDurationInMinutes: number\n  protected minimumAmountOfSleepInMinutes: number\n\n\n  constructor({\n    baseTime,\n    oneSleepCycleDurationInMinutes = 60 * 1.5,\n    minimumAmountOfSleepInMinutes = 60 * 1.5\n  }: Args) {\n    if (oneSleepCycleDurationInMinutes < this.MINIMUM_MINUTES)\n      throw new Error()\n\n    if (minimumAmountOfSleepInMinutes < this.MINIMUM_MINUTES)\n      throw new Error()\n\n    this.baseDate = new Date(`${this.DEFAULT_DATE} ${baseTime}`)\n    this.newBaseDate = this.baseDate\n    this.oneSleepCycleDurationInMinutes = oneSleepCycleDurationInMinutes\n    this.minimumAmountOfSleepInMinutes = minimumAmountOfSleepInMinutes\n\n    this.preRun()\n  }\n\n  /**\n   * Esse método deve ser sobrescrito pela classe filha.\n   *\n   * Se é implementado com `n1`+`n1` a classe filha calcula horários posteriores.\n   *\n   * Se é implementado com `n1`-`n1` a classe filha calcula horários prévios.\n   *\n   * @param n1 duração em minutos 1\n   * @param n2 duração em minutos 2\n   */\n  protected abstract operation(n1: number, n2: number): number\n\n  public run(): string {\n    const oneSleepCycleLaterOfBefore = new Date(this.newBaseDate.getTime())\n\n    oneSleepCycleLaterOfBefore.setMinutes(\n      this.operation(\n        oneSleepCycleLaterOfBefore.getMinutes(),\n        this.oneSleepCycleDurationInMinutes\n      )\n    )\n\n    this.newBaseDate = oneSleepCycleLaterOfBefore\n    return this.dateToTimeString(oneSleepCycleLaterOfBefore)\n  }\n\n  private preRun(): void {\n    if (this.oneSleepCycleDurationInMinutes === this.minimumAmountOfSleepInMinutes)\n      return\n\n    if (this.oneSleepCycleDurationInMinutes < this.minimumAmountOfSleepInMinutes) {\n      let numberOfSleepCycles = Math.floor(\n        this.minimumAmountOfSleepInMinutes / this.oneSleepCycleDurationInMinutes\n      ) + 1\n\n      if (this.minimumAmountOfSleepInMinutes % this.oneSleepCycleDurationInMinutes === 0)\n        numberOfSleepCycles--\n\n      for (let i = 0; i < numberOfSleepCycles - 1; i++) {\n        this.run()\n      }\n    }\n  }\n\n  private dateToTimeString(date: Date): string {\n    return date\n      .toLocaleTimeString('pt-BR')\n      .replace(/:\\d\\d$/, '')\n  }\n}\n","import CalculateOneSleepCycleService from './CalculateOneSleepCycleService'\nimport { Args } from './CalculateOneSleepCycleService'\n\n/**\n * Calcula horários a partir de `baseTime` em intervalos de\n * tempo de `sleepCycleDurationInMinutes`.\n *\n * @param {string} baseTime horário base no formato HH:mm\n * @param {number} sleepCycleDurationInMinutes duração de um ciclo de sono em minutos\n */\nexport default class CalculateOneSleepCycleLaterService extends CalculateOneSleepCycleService {\n  protected operation(mili1: any, mili2: any): number {\n    return mili1 + mili2\n  }\n}\n","export default function dateToTimeString(date: Date): string {\n  let hours = new String(date.getHours())\n  hours = hours.padStart(2, '0')\n  let minutes = new String(date.getMinutes())\n  minutes = minutes.padStart(2, '0')\n  return `${hours}:${minutes}`\n}\n\n","export default abstract class Tab {\n  htmlElement: HTMLDivElement\n\n  abstract setup(): void\n\n  constructor(\n    private document: Document,\n    readonly id: string,\n    readonly name: string,\n    readonly outputDivId?: string\n  ) {\n    this.htmlElement = this.document.createElement('div')\n    this.htmlElement.classList.add('tab')\n    this.htmlElement.classList.add('transparent')\n    this.htmlElement.classList.add('hide')\n    this.htmlElement.id = id\n  }\n}\n","import CalculateOneSleepCycleLaterService from '../services/CalculateOneSleepCycleLaterService'\nimport dateToTimeString from '../util/dateToTimeString'\nimport Tab from './Tab'\n\nexport default class TabSleep extends Tab {\n  public input: HTMLInputElement\n\n  constructor(document: Document) {\n    super(document, 'tab-sleep', 'Dormir')\n\n    const now = dateToTimeString(new Date())\n    this.htmlElement.innerHTML = `\n      <p>Eu quero dormir às:</p>\n\n      <label for=\"base-time-sleep\" class=\"form-label\">\n        <input class=\"form-control\" type=\"time\" id=\"base-time-sleep\" value=\"${now}\">\n      </label>\n\n      <p>pra acordar possivelmente às:</p>\n      <div id=\"times-wake-up\"></div>\n    `\n\n    this.input = this.htmlElement.querySelector('input')\n  }\n\n  setup(): void {\n    const onInputChange = (event: Event) => {\n      let baseTime = `${(<HTMLInputElement>event.target).value}`\n      const timesDiv = document.querySelector('#times-wake-up') as HTMLDivElement\n      timesDiv.innerText = ''\n\n      let oneSleepCycleLater: string\n      let calc = new CalculateOneSleepCycleLaterService({ baseTime })\n      let li: HTMLLIElement\n\n      for (let index = 0; index < 5; index++) {\n        oneSleepCycleLater = calc.run()\n        baseTime = oneSleepCycleLater\n        li = document.createElement('li')\n        li.innerText = oneSleepCycleLater\n        timesDiv.appendChild(li)\n      }\n    }\n\n    this.input.addEventListener('change', onInputChange)\n  }\n}\n\n","import CalculateOneSleepCycleService from './CalculateOneSleepCycleService'\n\n/**\n * Calcula horários prévios a `baseTime` em intervalos de\n * tempo de `sleepCycleDurationInMinutes`.\n *\n * @param {string} baseTime horário base no formato HH:mm\n * @param {number} sleepCycleDurationInMinutes duração de um ciclo de sono em minutos\n */\nexport default class CalculateOneSleepCycleBeforeService extends CalculateOneSleepCycleService {\n  protected operation(mili1: any, mili2: any): number {\n    return mili1 - mili2\n  }\n}\n","import CalculateOneSleepCycleBeforeService from '../services/CalculateOneSleepCycleBeforeService'\nimport dateToTimeString from '../util/dateToTimeString'\nimport Tab from './Tab'\n\nexport default class TabWakeUp extends Tab {\n  public input: HTMLInputElement\n\n  constructor(document: Document) {\n    super(document, 'tab-wake-up', 'Acordar', 'times-sleep')\n\n    const now = dateToTimeString(new Date())\n    this.htmlElement.innerHTML = `\n      <p>Eu quero acordar às:</p>\n\n      <label for=\"base-time-sleep\" class=\"form-label\">\n        <input class=\"form-control\" type=\"time\" id=\"base-time-wake-up\" value=\"${now}\">\n      </label>\n\n      <p>dormindo possivelmente às:</p>\n      <div id=\"times-sleep\"></div>\n    `\n\n    this.input = this.htmlElement.querySelector('input')\n  }\n\n  setup(): void {\n    const onInputChange = (event: Event) => {\n      let baseTime = `${(<HTMLInputElement>event.target).value}`\n      const timesDiv = document.querySelector('#times-sleep') as HTMLDivElement\n      timesDiv.innerText = ''\n\n      let oneSleepCycleBefore: string\n      let calc = new CalculateOneSleepCycleBeforeService({ baseTime })\n      let li: HTMLLIElement\n\n      for (let index = 0; index < 5; index++) {\n        oneSleepCycleBefore = calc.run()\n        baseTime = oneSleepCycleBefore\n        li = document.createElement('li')\n        li.innerText = oneSleepCycleBefore\n        timesDiv.appendChild(li)\n      }\n    }\n\n    this.input.addEventListener('change', onInputChange)\n  }\n}\n\n","import Tab from './Tab'\nimport TabManagerMenu from './TabManagerMenu'\n\nexport default class TabManager {\n  constructor(\n    private htmlElement: HTMLDivElement,\n    readonly tabManagerMenu: TabManagerMenu,\n    tabs: Tab[]\n  ) {\n    // Impede que o Hot Reload fique adicionando várias Tabs\n    this.htmlElement.innerText = ''\n    tabs.forEach(t => this.register(t))\n    this.htmlElement.prepend(tabManagerMenu.htmlElement)\n    this.setActive(tabs[0].id)\n    this.tabManagerMenu.setActive(tabs[0].id.replace(/^tab/, 'btn'))\n  }\n\n  register(tab: Tab): void {\n    tab.setup()\n    this.htmlElement.append(tab.htmlElement)\n  }\n\n  setActive(tabId: string) {\n    const currentActiveTab = this.htmlElement.querySelector('.tab.active')\n    currentActiveTab?.classList.add('transparent')\n    currentActiveTab?.classList.add('hide')\n    currentActiveTab?.classList.remove('active')\n\n    const toBeActivated = this.htmlElement.querySelector(`#${tabId}`)\n    toBeActivated.classList.remove('transparent')\n    toBeActivated.classList.remove('hide')\n    setTimeout(() => {\n      toBeActivated.classList.add('active')\n    }, 150);\n  }\n\n  setupMenuListeners() {\n    const setupListener = (button: HTMLButtonElement) => {\n      button.addEventListener('click', () => {\n        this.tabManagerMenu.setActive(button.id)\n        this.setActive(button.id.replace(/^btn/, 'tab'))\n        button.classList.add('active')\n      })\n    }\n\n    this.htmlElement.querySelectorAll('button')\n      .forEach(button => setupListener(button))\n  }\n}\n","export default class TabManagerMenu {\n  htmlElement: HTMLDivElement\n\n  constructor(private document: Document, tabs: { id: string, name: string }[]) {\n    this.htmlElement = this.document.createElement('div')\n    this.htmlElement.classList.add('tab-manager-menu')\n    this.htmlElement.innerHTML = tabs.map(\n      t => `<button id=\"btn-${t.id}\"> ${t.name} </button>`).join('')\n  }\n\n  setActive(buttonId: string): void {\n    const currentlyActiveButton = this.htmlElement.querySelector('button.active')\n    currentlyActiveButton?.classList.remove('active')\n\n    const toBeActivetated = this.htmlElement.querySelector(`#${buttonId}`)\n    toBeActivetated.classList.add('active')\n  }\n}\n","import Tab from './Tab';\n\nexport default class TabAbout extends Tab {\n  constructor(document: Document) {\n    super(document, 'tab-about', 'Sobre')\n    this.htmlElement.innerHTML = `\n      <p>Este aplicativo calcula a hora ideal para dormir e acordar baseado\n      em cilcos de sono.</p>\n\n      <br>\n      <p><strong> Créditos </strong></p>\n      <p>Feito por <a href=\"https://github.com/yudi-azvd\">Yudi Yamane</a></p>\n      <p>Código fonte: <a href=\"https://github.com/yudi-azvd/bedtime-calculator\">yudi-azvd/bedtime-calculator</a></p>\n      <p> <a href=\"https://www.flaticon.com/premium-icon/clock_2838590?term=clock&page=1&position=13&page=1&position=13&related_id=2838590&origin=search\">Relógio</a> da logo </p>\n      <p> <a href=\"https://www.flaticon.com/premium-icon/bed_3010012?term=bed&page=1&position=8&page=1&position=8&related_id=3010012&origin=search\">Cama</a> da logo </p>\n\n    `\n  }\n\n  setup(): void { }\n}\n","import TabSleep from './presentation/TabSleep'\nimport TabWakeUp from './presentation/TabWakeUp'\nimport TabManager from './presentation/TabManager'\nimport TabManagerMenu from './presentation/TabManagerMenu'\nimport TabAbout from './presentation/TabAbout'\n\nfunction main() {\n  const tabManagerHtmlElem = document.querySelector('.tab-manager') as HTMLDivElement\n  const tabs = [\n    new TabSleep(document),\n    new TabWakeUp(document),\n    new TabAbout(document),\n  ]\n\n  const tabManagerMenu = new TabManagerMenu(document,\n    tabs.map(tab => ({ id: tab.id.replace(/tab-/, ''), name: tab.name })))\n\n  const tabManager = new TabManager(\n    tabManagerHtmlElem,\n    tabManagerMenu,\n    tabs,\n  )\n\n  tabManager.setupMenuListeners()\n}\n\nmain()\n"],"names":["$04a9f6b70c5a64b0$export$2e2bcd8739ae039","baseTime","oneSleepCycleDurationInMinutes","minimumAmountOfSleepInMinutes","this","MINIMUM_MINUTES","DEFAULT_DATE","Error","baseDate","Date","newBaseDate","preRun","run","oneSleepCycleLaterOfBefore","getTime","setMinutes","operation","getMinutes","dateToTimeString","numberOfSleepCycles","Math","floor","i","date","toLocaleTimeString","replace","$3dd853ceb74a3d5e$export$2e2bcd8739ae039","mili1","mili2","hours","String","getHours","padStart","minutes","$91239879e4e0b3f0$export$2e2bcd8739ae039","document","id","name","outputDivId","htmlElement","createElement","classList","add","$eb058dd2256f6d64$export$2e2bcd8739ae039","document1","super","now","$855defcea978a3aa$export$2e2bcd8739ae039","innerHTML","querySelector","event","target","value","timesDiv","oneSleepCycleLater","innerText","li","calc","index","$776b1ee4edcfb4c1$export$2e2bcd8739ae039","$97b7d3896dc5aead$export$2e2bcd8739ae039","oneSleepCycleBefore","$24f994d4033b4b19$export$2e2bcd8739ae039","tabManagerMenu","tabs","forEach","t","register","prepend","setActive","tab","setup","append","tabId","currentActiveTab","remove","toBeActivated","setTimeout","setupMenuListeners","setupListener","button","addEventListener","querySelectorAll","$7d7eb1325f1c3053$export$2e2bcd8739ae039","map","join","buttonId","$bb8a9aee58162ff9$export$2e2bcd8739ae039","tabManagerHtmlElem","$5ba171b4a505aeb2$var$main"],"version":3,"file":"index.2645592e.js.map"}